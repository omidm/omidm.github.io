<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="Omid Mashayekhi's Personal Webpage">
    <meta name="author" content="Omid Mashayekhi">
    <link rel="icon" href="images/stanford.ico">

    <title>Omid Mashayekhi</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="css/custom.css" rel="stylesheet">

  </head>

  <body>

    <!-- script for Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-100564383-2', 'auto');
      ga('send', 'pageview');
    
    </script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="js/bootstrap.js"></script>
    <script src="js/scroll.js"></script>
    <script src="js/hide-nav.js"></script>


    <!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">
            Omid Mashayekhi
          </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a id="home-link" href="#">Home</a></li>
            <li><a id="projects-link" href="#">Projects</a></li>
            <li><a id="papers-link" href="#">Papers</a></li>
            <li><a id="resume-link" href="#">Resume</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    <h1 name="home" style=""></h1>


      <div class="row" style="padding-bottom: 30px">
        <div class="col-md-3 col-sm-3">
          <img src="images/omidm.jpg" alt="Omid Mashayekhi" style="width: 90%; max-width:300px;"/>
        </div>
        <div class="col-md-9 col-sm-9">
          <h1 style="padding-bottom: 10pt;"> Omid Mashayekhi </h1>
          <table>
            <!-- tr>
              <td style="padding: 2pt;">
                <img src="images/envelope-icon.png" style="width: 100%; max-width:30px; text-align: left;"/>
              </td>
              <td>
                <img src="images/omidm-email.png" style="width: 60%; max-width:400px; text-align: left;"/>
              </td>
            </tr -->
            <tr>
              <td style="padding: 2pt;">
                <img src="images/gmail-icon.png" style="width: 100%; max-width:30px; text-align: left;"/>
              </td>
              <td>
                <img src="images/omidm-gmail.png" style="width: 70%; max-width:400px; text-align: left;"/>
              </td>
            </tr>
            <tr>
              <td style="padding: 1pt;">
                <img src="images/github-icon.png" style="width: 100%; max-width:40px; text-align: left;"/>
              </td>
              <td style="padding-left: 3pt; font-size: 12pt;">
                <a href="https://www.github.com/omidm" target="_blank">github.com/omidm</a>
              </td>
            </tr>
            <tr>
              <td style="padding: 2pt;">
                <img src="images/linkedin-icon.png" style="width: 100%; max-width:30px; text-align: left;"/>
              </td>
              <td style="padding-left: 3pt; font-size: 12pt;">
                <a href="https://www.linkedin.com/in/omidmsk/" target="_blank">linkedin.com/in/omidmsk</a>
              </td>
            </tr>
            <tr>
              <td style="padding: 2pt;">
                <img src="images/facebook-icon.png" style="width: 100%; max-width:30px; text-align: left;"/>
              </td>
              <td style="padding-left: 3pt; font-size: 12pt;">
                <a href="https://www.facebook.com/omidmsk" target="_blank">facebook.com/omidmsk</a>
              </td>
            </tr>
            <!-- tr>
              <td style="padding: 2pt;">
                <img src="images/map-icon.png" style="width: 100%; max-width:30px; text-align: left;"/>
              </td>
              <td style="padding-left: 3pt; font-size: 12pt;">
                <a href="https://goo.gl/maps/CJDwh1B35yL2" target="_blank">284 Gates Hall, Stanford University, Stanford, CA, 94305</a>
              </td>
            </tr -->
          </table>
        </div>
        <!-- div class="col-md-3 col-sm-3">
          <a href="http://www.stanford.edu" target="_blank">
            <img src="images/stanford-logo.png" style="width: 90%; max-width:150px;"/>
          </a>
        </div -->
      </div>

      <div class="row block">
        <div class="col-md-12 col-sm-12">
          <p style="text-align: justify; font-size: 13pt;">
            I am a graduate student at <a href="http://www.stanford.edu"
            target="_blank">Stanford University</a>, currently, a Ph.D.
            candidate in <a href="http://ee.stanford.edu"
            target="_blank">Electrical Engineering</a>, and a Ph.D. minor
            candidate in <a href="http://cs.stanford.edu"
            target="_blank">Computer Science</a>.  My interests include cloud
            computing, distributed systems, and networking systems. I work with
            Professor <a/ href="http://csl.stanford.edu/~pal/"
            target="_blank">Philip Levis</a> as a member of <a
            href="http://sing.stanford.edu" target="_blank">Stanford Information
            Networks Group (SING)</a>. I received M.S. degree from <a
            href="http://www.stanford.edu" target="_blank">Stanford
            University</a> in 2013, and B.S.  degree from <a
            href="http://www.sharif.edu" target="_blank"> Sharif University</a>
            in 2011, both in Electrical Engineering.  
          </p>
        </div>
      </div>



      <h1 name="projects"> Projects </h1>

      <h2> Main Research Projects </h2>

      <div class="jumbotron">
      <div class="row">
        <div class="col-md-2 col-sm-2">
          <a href="http://nimbus.stanford.edu" target="_blank">
            <img src="images/nimbus-logo.png" style="padding-top: 20px; width: 100%; max-width:200px;"/>
            </a>
        </div>
        <div class="col-md-10 col-sm-10">
          <h3>Nimbus</h3>
          <p style="font-size: 12pt;">
            Nimbus is a general purpose cloud computing system specially
            designed for computations with short tasks. Nimbus is developed in
            C++ and the API offers a data model similar to
            <a href="http://spark.apache.org/" target="_blank">Spark</a> and
            <a href="https://www.microsoft.com/en-us/research/project/naiad/" target="_blank">Naiad</a>.
            The key difference between Nimbus and its counterparts is the novel
            control plane abstraction called <strong>Execution
            Templates</strong>. For jobs with
            short tasks the runtime overhead becomes comparable to the task
            itself. For example for an application with 4ms tasks, Sparks
            runtime overhead is about 98%. Execution templates enable Nimbus to
            schedule and drive jobs with tasks as short as 100us over large
            number of workers at scale with negligible runtime overhead. For
            more information visit <a
            href="http://nimbus.stanford.edu" target="_blank">Nimbus</a> home page.
          </p>
        </div>
      </div>
      </div>

      <div class="jumbotron">
      <div class="row">
        <div class="col-md-2 col-sm-2">
          <a href="materials/janus.pdf" target="_blank">
            <img src="images/janus-logo.png" style="padding-top: 20px; width: 100%; max-width:200px;"/>
          </a>
        </div>
        <div class="col-md-10 col-sm-10">
          <h3>Janus</h3>
          <p style="font-size: 12pt;">
            In this project, we investigate novel techniques to design MAC
            protocol for the <a href="https://sing.stanford.edu/site/projects/7"
            target="_blank">Full Duplex radio</a>. This project follows SINGâ€™s
            earlier paper on single channel full duplex wireless network (please
                see <a href="https://sing.stanford.edu/fullduplex/"
                target="_blank">here</a>), which explores feasible
            implementation of the physical layer for efficient simultaneous
            transmission and reception.  We consider the very fundamental
            characteristics of a full duplex network and try to design a MAC
            protocol which perfectly takes the advantages of the freedom
            provided by the physical layer.  Specially, the goal is to improve
            the throughput as much as two times of the ordinary half duplex
            systems while remaining fair to all the users. You can find our
            paper <a href="materials/janus.pdf" target="_blank">here</a>. 
          </p>
        </div>
      </div>
      </div>


      <h2> Older Research Projects </h2>

      <div class="row block">
        <div class="col-md-2 col-sm-2">
          <a href="http://nimbus.stanford.edu" target="_blank">
            <img src="images/overloaded-codes.png" style="padding-top: 20px; width: 100%; max-width:200px;"/>
            </a>
        </div>
        <div class="col-md-10 col-sm-10">
            <h3>Overloaded Codes</h3>
            <p style="font-size: 12pt;">
              As my undergraduate research thesis, I worked on developing
              overloaded codes with efficient decoders for CDMA systems.  These
              codes not only have really simple decoder but also show the
              bit-error-rate (BER) performance almost as good as the
              maximum-likelihood (ML) decoder. The novel coding matrices are
              called logical signature matrices (LSM), which results in
              efficient decoding on the receiver side with only few
              comparisons. We have patented the results, and you can find  a
              copy of it <a href="materials/patent.pdf"
              target="_blank">here</a>.
            </p>
        </div>
      </div>



      <h2> Selected Short Projects </h2>

      <div class="jumbotron">
        <div class="row">
          <div class="col-md-2 col-sm-2">
            <a href="materials/predicting-x86.pdf" target="_blank">
              <img src="images/predicting-logo.png" style="padding-top: 20px; width: 100%; max-width:200px;"/>
            </a>
          </div>
          <div class="col-md-8 col-sm-8">
            <h3>x86 Runtime Prediction</h3>
            <p style="font-size: 12pt;">
              Predicting x86 program runtime for Intel processor. As a part of
              the machine learning course at Stanford (<a
              href="http://cs229.stanford.edu/" target="_blank">CS229</a>), we
              developed a series of supervised learning methods for predicting
              the runtime length of serialized x86 programs for Intel
              processors. Our generative model predicts runtime for programs
              with arbitrary numbers of instructions with 12% error.
            </p>
          </div>
          <div class="col-md-2 col-sm-2">
            <a class="btn-lg" href="materials/predicting-x86.pdf" target="_blank">
              <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
            </a>
            <a class="btn-lg" href="materials/cs229-poster.pdf" target="_blank">
              <span class="glyphicon glyphicon-blackboard" aria-hidden="true" style="font-size: 30px;"></span>
            </a>
          </div>
        </div>
      </div>

      <div class="jumbotron">
        <div class="row">
          <div class="col-md-2 col-sm-2">
            <a href="materials/packet-classification.pdf" target="_blank">
              <img src="images/packet-logo.png" style="padding-top: 20px; width: 100%; max-width:200px;"/>
            </a>
          </div>
          <div class="col-md-8 col-sm-8">
            <h3>Packet Classification</h3>
            <p style="font-size: 12pt;">
              Novel and optimized methods for packet classification when both
              rules and keys contain wildcard expressions. This work introduces
              a software based algorithm which is memory efficient, does not
              need expansion for rules and keys containing wildcards, is
              scalable, and provides multi-match results.
            </p>
          </div>
          <div class="col-md-2 col-sm-2">
            <a class="btn-lg" href="materials/packet-classification.pdf" target="_blank">
              <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
            </a>
            <a class="btn-lg" href="materials/ee384x-presentation.pdf" target="_blank">
              <span class="glyphicon glyphicon-blackboard" aria-hidden="true" style="font-size: 30px;"></span>
            </a>
          </div>
        </div>
      </div>


      <div class="jumbotron">
        <div class="row">
          <div class="col-md-2 col-sm-2">
            <a href="https://reproducingnetworkresearch.wordpress.com/2012/06/06/dcell-a-scalable-and-fault-tolerant-network-structure-for-data-centers/" target="_blank">
              <img src="images/dcell-logo.png" style="padding-top: 20px; width: 100%; max-width:200px;"/>
            </a>
          </div>
          <div class="col-md-10 col-sm-10">
            <h3>DCell with OpenFlow</h3>
            <p style="font-size: 12pt;">
              Simulating DCell topology and routing for data centers using
              Mininet and OpenFlow controller. Each year, advanced networking
              course at Stanford (<a
              href="http://web.stanford.edu/class/cs244/"
              target="_blank">CS244</a>) publishes a <a
              href="https://reproducingnetworkresearch.wordpress.com/"
              target="_blank">blog</a> on reproducing the results reported in
              the literature by students. Yo can find our report  <a
              href="https://reproducingnetworkresearch.wordpress.com/2012/06/06/dcell-a-scalable-and-fault-tolerant-network-structure-for-data-centers/"
              target="_blank">here </a>.
            </p>
          </div>
        </div>
      </div>

      <div class="jumbotron">
        <div class="row">
          <div class="col-md-2 col-sm-2">
            <a href="materials/spectral-utilization.pdf" target="_blank">
              <img src="images/spectral-logo.png" style="padding-top: 20px; width: 100%; max-width:200px;"/>
            </a>
          </div>
          <div class="col-md-8 col-sm-8">
            <h3>Cognitive Radio Devices</h3>
            <p style="font-size: 12pt;">
              This work is a literature survey on cognitive radio devices as a
              part of wireless networking course at Stanford (<a
              href="http://web.stanford.edu/class/ee359/"
              target="_blank">EE359</a>).
            </p>
          </div>
          <div class="col-md-2 col-sm-2">
            <a href="materials/spectral-utilization.pdf" target="_blank">
              <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
            </a>
          </div>
        </div>
      </div>


      <h1 name="papers" style="padding-bottom: 20px"> Papers </h1>

      <h2>Publications</h2>

      <div class="jumbotron">
        <div class="row">
          <div class="col-md-9 col-sm-9">
            <dl>
              <dt>
                Execution Templates: Caching Control Plane Decisions for Strong Scaling of Data Analytics
              </dt>
              <dd>
                Omid Mashayekhi, Hang Qu, Chinmayee Shah, Philip Levis
              </dd>
              <dd>
                In proceedings of 2017 USENIX Annual Technical Conference (USENIX ATC '17)
              </dd>
            </dl>
          </div>
          <div class="col-md-3 col-sm-3">
                <a class="btn-lg" href="materials/nimbus-atc.pdf" target="_blank">
                  <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
                <a class="btn-lg" href="materials/nimbus-atc-slides.pdf" target="_blank">
                  <span class="glyphicon glyphicon-blackboard" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
                <a class="btn-lg" href="https://www.usenix.org/conference/atc17/technical-sessions/presentation/mashayekhi" target="_blank">
                  <span class="glyphicon glyphicon-globe" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
          </div>
        </div>
        <div class="row-padded">
          <dl>
            <dt>
              Abstract
            </dt>
            <dd>
              Control planes of cloud frameworks trade off between scheduling
              granularity and performance. Centralized systems schedule at task
              granularity, but only schedule a few thousand tasks per second.
              Distributed systems schedule hundreds of thousands of tasks per
              second but changing the schedule is costly.

              We present execution templates, a control plane abstraction that can
              schedule hundreds of thousands of tasks per second while supporting
              fine-grained, per-task scheduling decisions. Execution templates
              leverage a programâ€™s repetitive control flow to cache blocks of
              frequently-executed tasks. Executing a task in a template requires
              sending a single message. Large-scale scheduling changes install new
              templates, while small changes apply edits to existing templates.

              Evaluations of execution templates in Nimbus, a data analytics
              framework, find that they provide the fine-grained scheduling
              flexibility of centralized control planes while matching the strong
              scaling of distributed ones. Execution templates support complex,
              real-world applications, such as a fluid simulation with a triply
              nested loop and data dependent branches.
            </dd>
          </dl>
        </div>
      </div>




      <div class="jumbotron">
        <div class="row">
          <div class="col-md-9 col-sm-9">
            <dl>
              <dt>
                Janus: A Novel MAC Protocol for Full Duplex Radio 
              </dt>
              <dd>
                Jae Young Kim, Omid Mashayekhi, Hang Qu, Maria Kazandjieva, and Philip Levis
              </dd>
              <dd>
                Stanford CSTR 2013-02, 2013
              </dd>
            </dl>
          </div>
          <div class="col-md-3 col-sm-3">
                <a class="btn-lg" href="http://hci.stanford.edu/cstr/reports/2013-02.pdf" target="_blank">
                  <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
          </div>
        </div>
        <div class="row-padded">
          <dl>
            <dt>
              Abstract
            </dt>
            <dd>
              This paper presents Janus, a novel MAC protocol for
              fullâ€“duplex wireless networks. Unlike other full-duplex
              MACs, Janus allows partially interfering nodes to cooperate
              by finding the appropriate transmission rates based on
              interference levels, making better use of the channel. Computing
              the optimal schedule and transmission rates is NPComplete,
              so Janus uses a cheaper heuristic approach. Janus
              also ensures that channel access time is shared fairly between
              all nodes. Janus has lower per-packet overhead compared
              to CSMA/CA because it eliminates random back-off
              and lets nodes transmit multiple packets with a single set of
              control packets. We show that for a setup with one access
              point and three nodes, Janus achieves 2.5X the throughput
              of halfâ€“duplex system based on CSMA/CA.
            </dd>
          </dl>
        </div>
      </div>



      <div class="jumbotron">
        <div class="row">
          <div class="col-md-9 col-sm-9">
            <dl>
              <dt>
                Uniquely Decodable Codes with Fast Decoder for Overloaded Synchronous CDMA Systems 
              </dt>
              <dd>
                Omid Mashayekhi, Farokh Marvasti
              </dd>
              <dd>
                IEEE Transactions on Communication, vol. 60, no. 11, pp. 3145-3149, November 2012
              </dd>
            </dl>
          </div>
          <div class="col-md-3 col-sm-3">
                <a class="btn-lg" href="materials/overloaded-codes.pdf" target="_blank">
                  <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
            <a class="btn-lg" href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?reload=true&tp=&arnumber=6266766&contentType=Early+Access+Articles&searchField%3DSearch_All%26queryText%3DO.+Mashayekhi" target="_blank">
                  <span class="glyphicon glyphicon-globe" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
          </div>
        </div>
        <div class="row-padded">
          <dl>
            <dt>
              Abstract
            </dt>
            <dd>
              In this paper, we introduce a new class of signature matrices for
              overloaded synchronous CDMA systems that have a very low complexity
              decoder. While overloaded systems are more efficient from the
              bandwidth point of view, the Maximum Likelihood (ML) implementation
              for decoding is impractical even for moderate dimensions. Simulation
              results show that the performance of the proposed decoder is very
              close to that of the ML decoder. Indeed, the proposed decoding
              scheme needs neither multiplication nor addition and requires only a
              few comparisons . Furthermore, the computational complexity and the
              probability of error vs. Signal to Noise Ratios (SNR) are derived
              analytically.
            </dd>
          </dl>
        </div>
      </div>


      <h2> Presentations </h2>

      <div class="jumbotron">
        <div class="row">
          <div class="col-md-9 col-sm-9">
            <dl>
              <dt>
                Scalable, Fast Cloud Computing with Execution Templates
              </dt>
              <dd>
                Omid Mashayekhi, Hang Qu, Chinmayee Shah, Philip Levis
              </dd>
              <dd>
                Poster presentation at 2016 USENIX Symposium on Operating Systems Design and Implementation (OSDI'16)
              </dd>
            </dl>
          </div>
          <div class="col-md-3 col-sm-3">
                <a class="btn-lg" href="materials/nimbus-osdi-poster.pdf" target="_blank">
                  <span class="glyphicon glyphicon-blackboard" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
                <a class="btn-lg" href="https://www.usenix.org/conference/osdi16/poster-session" target="_blank">
                  <span class="glyphicon glyphicon-globe" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
          </div>
        </div>
      </div>

      <h2> Technical Reports</h2>

      <div class="jumbotron">
        <div class="row">
          <div class="col-md-9 col-sm-9">
            <dl>
              <dt>
                Distributed Graphical Simulation in the Cloud
              </dt>
              <dd>
                Omid Mashayekhi, Chinmayee Shah, Hang Qu, Andrew Lim, Philip Levis
              </dd>
              <dd>
                arXiv:1606.01966 [cs.DC], 2016
              </dd>
            </dl>
          </div>
          <div class="col-md-3 col-sm-3">
                <a class="btn-lg" href="materials/nimbus-socc.pdf" target="_blank">
                  <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
                <a class="btn-lg" href="http://arxiv.org/abs/1606.01966" target="_blank">
                  <span class="glyphicon glyphicon-globe" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
          </div>
        </div>
        <div class="row-padded">
          <dl>
            <dt>
              Abstract
            </dt>
            <dd>
              Graphical simulations are a cornerstone of modern media and
              films. But existing software packages are designed to run on HPC
              nodes, and perform poorly in the computing cloud.  These
              simulations have complex data access patterns over complex data
              structures, and mutate data arbitrarily, and so are a poor fit for
              existing cloud computing systems. We describe a software
              architecture for running graphical simulations in the cloud that
              decouples control logic, computations and data exchanges. This
              allows a central controller to balance load by redistributing
              computations, and recover from failures. Evaluations show that the
              architecture can run existing, state-of-the-art simulations in the
              presence of stragglers and failures, thereby enabling this large
              class of applications to use the computing cloud for the first
              time.
            </dd>
          </dl>
        </div>
      </div>



      <div class="jumbotron">
        <div class="row">
          <div class="col-md-9 col-sm-9">
            <dl>
              <dt>
                Scalable, Fast Cloud Computing with Execution Templates
              </dt>
              <dd>
                Omid Mashayekhi, Hang Qu, Chinmayee Shah, Philip Levis
              </dd>
              <dd>
                arXiv:1606.01972 [cs.DC], 2016
              </dd>
            </dl>
          </div>
          <div class="col-md-3 col-sm-3">
                <a class="btn-lg" href="materials/nimbus-osdi.pdf" target="_blank">
                  <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
                <a class="btn-lg" href="http://arxiv.org/abs/1606.01972" target="_blank">
                  <span class="glyphicon glyphicon-globe" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
          </div>
        </div>
        <div class="row-padded">
          <dl>
            <dt>
              Abstract
            </dt>
            <dd>
            Large scale cloud data analytics applications are often CPU
            bound. Most of these cycles are wasted: benchmarks written in C++ run
            10-51 times faster than frameworks such as Naiad and Spark.  However,
            calling faster implementations from those frameworks only sees
            moderate (4-5x) speedups because their control planes cannot schedule
            work fast enough.
            
            This paper presents execution templates, a control plane abstraction
            for CPU-bound cloud applications, such as machine learning.  Execution
            templates leverage highly repetitive control flow to cache scheduling
            decisions as templates.  Rather than reschedule hundreds of
            thousands of tasks on every loop execution, nodes instantiate these
            templates.  A controller's template specifies the execution across all
            worker nodes, which it partitions into per-worker templates. To ensure
            that templates execute correctly, controllers dynamically patch
            templates to match program control flow.  We have implemented
            execution templates in Nimbus, a C++ cloud computing framework.
            Running in Nimbus, analytics benchmarks can run 16-43 times faster
            than in Naiad and Spark. Nimbus's control plane can scale out to run
            these faster benchmarks on up to 100 nodes (800 cores).
            </dd>
          </dl>
        </div>
      </div>


      <div class="jumbotron">
        <div class="row">
          <div class="col-md-9 col-sm-9">
            <dl>
              <dt>
                Canary: A Scheduling Architecture for High Performance Cloud Computing
              </dt>
              <dd>
                Hang Qu, Omid Mashayekhi, David Terei, Philip Levis
              </dd>
              <dd>
                Stanford CSTR 2016-01, 2016
              </dd>
            </dl>
          </div>
          <div class="col-md-3 col-sm-3">
                <a class="btn-lg" href="http://hci.stanford.edu/cstr/reports/2016-01.pdf" target="_blank">
                  <span class="glyphicon glyphicon-file" aria-hidden="true" style="font-size: 30px;"></span>
                </a>
          </div>
        </div>
        <div class="row-padded">
          <dl>
            <dt>
              Abstract
            </dt>
            <dd>
              We present Canary, a scheduling architecture that allows
              high performance analytics workloads to scale out to run
              on thousands of cores. Canary is motivated by the observation
              that a central scheduler is a bottleneck for high
              performance codes: a handful of multicore workers can
              execute tasks faster than a controller can schedule them.
              The key insight in Canary is to reverse the responsibilities
              between controllers and workers. Rather than
              dispatch tasks to workers, which then fetch data as necessary,
              in Canary the controller assigns data partitions to
              workers, which then spawn and schedule tasks locally.
              We evaluate three benchmark applications in Canary
              on up to 64 servers and 1,152 cores on Amazon EC2.
              Canary achieves up to 9âˆ’90Ã— speedup over Spark and
              up to 4Ã— speedup over GraphX, a highly optimized graph
              analytics engine. While current centralized schedulers
              can schedule 2,500 tasks/second, each Canary worker can
              schedule 136,000 tasks/second per core and experiments
              show this scales out linearly, with 64 workers scheduling
              over 120 million tasks per second, allowing Canary to
              support optimized jobs running on thousands of cores.
            </dd>
          </dl>
        </div>
      </div>


      <h1 name="resume" style="padding-bottom: 20px"> Resume </h1>

      <div class="jumbotron">
        <p style="text-align: left; font-size: 14pt; display: inline-block;">
          You can find a copy of my resume 
          <a href="materials/resume.pdf" target="_blank">here</a>.
        </p>
      </div>


    </div> <!-- /container -->

  </body>
</html>

